Given an M x N matrix, with a few hurdles arbitrarily placed, calculate the length of longest possible route possible from source to destination within the matrix. We are allowed to move to only adjacent cells which are not hurdles. The route cannot contains any diagonal moves and a location once visited in a particular path cannot be visited again.

For example, longest path with no hurdles from source to destination is highlighted for below matrix. The length of the path is 24.


 { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 0, 1, 1, 0, 1, 1, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }



        https://www.geeksforgeeks.org/longest-possible-route-in-a-matrix-with-hurdles/



        #include <bits/stdc++.h>
using namespace std;
#define imp() ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pb push_back
#define endl "\n"
#define lli long long int 
#define ll long long 
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
bool isValid(int x,int y,int m,int n)
{
    if(x>=m || y>=n || x<0 || y<0)
    return false;
    return true;
}
void backtrack(vector<vector<int>>&grid,int i,int j,int src,int dest,int &maxPath,int path,int m,int n){
    if(i>=m || j>=n || j<0 || i<0 || grid[i][j]==0)
    return ;
    if(i==src && j==dest){
        maxPath=max(maxPath,path);
        return ;
    }
    grid[i][j]=0;
    for(int k=0;k<4;k++)
    {
        int kx=i+dx[k];
        int ky=j+dy[k];
        backtrack(grid,kx,ky,src,dest,maxPath,path+1,m,n);
    }
    grid[i][j]=1;
    
}
int main(){
    int n,m,src,dest;cin>>m>>n>>src>>dest;
    vector<vector<int>>grid(m,vector<int>(n,-2));
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            int x;
            cin>>x;
            grid[i][j]=x;
        }
    }
    vector<vector<int>>dist(m,vector<int>(n,-1));
    int maxPath=INT_MIN;
    backtrack(grid,0,0,src,dest,maxPath,0,m,n);
    cout<<"The longest path is "<<maxPath<<"\n";
    return 0;
   
    
}





Printing the path too-


#include <bits/stdc++.h>
using namespace std;
#define imp() ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pb push_back
#define endl "\n"
#define lli long long int 
#define ll long long 
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
vector<pair<int,int>>print;
vector<pair<int,int>>ans;
bool isValid(int x,int y,int m,int n)
{
    if(x>=m || y>=n || x<0 || y<0)
    return false;
    return true;
}
void backtrack(vector<vector<int>>&grid,int i,int j,int src,int dest,int &maxPath,int path,int m,int n){
    if(i>=m || j>=n || j<0 || i<0 || grid[i][j]==0)
    return ;
    if(i==src && j==dest){
        if(path>maxPath){
        maxPath=path;
        ans=print;
        return ;
        }
    }
    grid[i][j]=0;
    for(int k=0;k<4;k++)
    {
        int kx=i+dx[k];
        int ky=j+dy[k];
        print.push_back({kx,ky});
        backtrack(grid,kx,ky,src,dest,maxPath,path+1,m,n);
        print.pop_back();

    }
    grid[i][j]=1;
    
}
int main(){
    int n,m,src,dest;cin>>m>>n>>src>>dest;
    vector<vector<int>>grid(m,vector<int>(n,-2));
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            int x;
            cin>>x;
            grid[i][j]=x;
        }
    }
    vector<vector<int>>dist(m,vector<int>(n,-1));
    int maxPath=INT_MIN;
    backtrack(grid,0,0,src,dest,maxPath,0,m,n);
    cout<<"The longest path is "<<maxPath<<"\n";
    cout<<"the path to be taken is "<<"\n";
    cout<<0<<" "<<0<<"\n";
    for(int i=0;i<ans.size();i++)
    {
        cout<<ans[i].first<<" "<<ans[i].second<<"\n";
    }
    return 0;
   
    
}



