Given a positive integer, find the maximum integer possible by doing at-most K swap operations on its digits.
Examples: 

Input: M = 254, K = 1
Output: 524
Swap 5 with 2 so number becomes 524

Input: M = 254, K = 2
Output: 542
Swap 5 with 2 so number becomes 524
Swap 4 with 2 so number becomes 542

Input: M = 68543, K = 1 
Output: 86543
Swap 8 with 6 so number becomes 86543

Input: M = 7599, K = 2
Output: 9975
Swap 9 with 5 so number becomes 7995
Swap 9 with 7 so number becomes 9975

Input: M = 76543, K = 1 
Output: 76543
Explanation: No swap is required.

Input: M = 129814999, K = 4
Output: 999984211
Swap 9 with 1 so number becomes 929814991
Swap 9 with 2 so number becomes 999814291
Swap 9 with 8 so number becomes 999914281
Swap 1 with 8 so number becomes 999984211




class Solution
{
    public:
    void find(string str,int k,string &maxx){
        if(k==0)
       return ;
       for(int i=0;i<str.size()-1;i++)
       {
          for(int j=i+1;j<str.size();j++)
          {
            if(str[i]<str[j]){
                swap(str[i],str[j]);
            if(str>maxx)
            maxx=str;
            find(str,k-1,maxx);
            swap(str[i],str[j]);//undo our change for new set 
          }
         }
      }
}
    string findMaximumNum(string str, int k)
    {
       // code here.
      string maxx=str;
      find(str,k,maxx);
      return maxx;
    }
};



TC:O((n^2)^k)
SC:O(n)

efficient solution is :


