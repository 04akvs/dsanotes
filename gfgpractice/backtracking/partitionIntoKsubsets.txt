Given an integer array a[ ] of N elements and an integer K, the task is to check if the array a[ ] could be divided into K non-empty subsets with equal sum of elements.
Note: All elements of this array should be part of exactly one partition.

Example 1:

Input: 
N = 5
a[] = {2,1,4,5,6}
K = 3
Output: 
1
Explanation: we can divide above array 
into 3 parts with equal sum as (2, 4), 
(1, 5), (6)
â€‹Example 2:

Input: 
N = 5 
a[] = {2,1,5,5,6}
K = 3
Output: 
0
Explanation: It is not possible to divide
above array into 3 parts with equal sum.
Your Task:
You don't need to read input or print anything. Your task is to complete the function isKPartitionPossible() which takes the array a[], the size of the array N, and the value of K as inputs and returns true(same as 1) if possible, otherwise false(same as 0).

Expected Time Complexity: O(N*2N).
Expected Auxiliary Space: O(2N).

Constraints:
1 ≤ K ≤ N ≤ 10
1 ≤ a[i] ≤ 100



bool backtrack(int nums[],vector<bool>visited,int start,int k,int total,int sum,int n){
      if(k==1)
      return true;
      if(sum==total){
          return backtrack(nums,visited,0,k-1,total,0,n);
      }
      for(int i=start;i<n;i++)
      {
          if(!visited[i]){
              visited[i]=true;
              if(backtrack(nums,visited,i+1,k,total,sum+nums[i],n))
              return true;
              visited[i]=false;
          }
      }
      return false;
  }
    bool isKPartitionPossible(int nums[], int n, int k)
    {
         //Your code here
         int total=0;
        for(int i=0;i<n;i++){
            total+=nums[i];
        }
        if(total%k!=0)//the sum should be divisible 
            return false;
         vector<bool> visited(n, false);
        return backtrack(nums,visited,0,k,total/k,0,n);
    }


    TC:O(n*2^n)