



Given a string s and a dictionary of words dict of length n, add spaces in s to construct a sentence where each word is a valid dictionary word. Each dictionary word can be used more than once. Return all such possible sentences.

Follow examples for better understanding.

Example 1:

Input: s = "catsanddog", n = 5 
dict = {"cats", "cat", "and", "sand", "dog"}
Output: (cats and dog)(cat sand dog)
Explanation: All the words in the given 
sentences are present in the dictionary.
Example 2:

Input: s = "catsandog", n = 5
dict = {"cats", "cat", "and", "sand", "dog"}
Output: Empty
Explanation: There is no possible breaking 
of the string s where all the words are present 
in dict.
Your Task:
You do not need to read input or print anything. Your task is to complete the function wordBreak() which takes n, dict and s as input parameters and returns a list of possible sentences. If no sentence is possible it returns an empty list.

Expected Time Complexity: O(N2*n) where N = |s|
Expected Auxiliary Space: O(N2)

Constraints:
1 ≤ n ≤ 20
1 ≤ dict[i] ≤ 15
1 ≤ |s| ≤ 500 






class Solution{
public:
void backtrack(vector<string>&ans,unordered_map<string,bool>&m,string s,string str,int n){
    //generate all prefixes 
    for(int i=1;i<=n;i++)
    {
        string res=s.substr(0,i);
        if(m[res]==true)//means present
        {
            // cout<<res<<" ";
            if(i==n)
        {
            str+=res;
            ans.push_back(str);
           // cout<<str<<" ";
            return ;
        }
           backtrack(ans,m,s.substr(i,n-i),str+res+" ",n-i);
        }
        
    }
}
    vector<string> wordBreak(int n, vector<string>& dict, string s)
    {
        // code here
        //we need to generate all prefixes 
        vector<string>ans;
        unordered_map<string,bool>m;//stores freq of each dictionary word
        for(int i=0;i<dict.size();i++)
        {
            m[dict[i]]=true;
        }
        backtrack(ans,m,s,"",s.size());
        return ans;
        
    }
};
