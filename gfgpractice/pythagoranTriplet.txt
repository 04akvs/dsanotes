Given an array arr of N integers, write a function that returns true if there is a triplet (a, b, c) that satisfies a2 + b2 = c2, otherwise false.

Example 1:

Input:
N = 5
Arr[] = {3, 2, 4, 6, 5}
Output: Yes
Explanation: a=3, b=4, and c=5 forms a
pythagorean triplet.
Example 2:

Input:
N = 3
Arr[] = {3, 8, 5}
Output: No
Explanation: No such triplet possible.


brute force : run three loops and check 
TC:O(n*n*n)


method 2 : sort the array and use two pointer technique 


class Solution{
public:
	// Function to check if the
	// Pythagorean triplet exists or not
	bool checkTriplet(int arr[], int n) {
	    // code here
	    
	   for(int i=0;i<n;i++)
	   {
	       arr[i]=arr[i]*arr[i];
	      
	   }
	   int sum=0;sort(arr,arr+n);
	   for(int i=0;i<n-2;i++)
	   {
	       int j=i+1;int k=n-1;
	       while(j<k)
	       {
	           if(arr[i]+arr[j]==arr[k])
	           {
	               return true;
	               
	           }
	           else if(arr[i]+arr[j]<arr[k])
	           {
	               j++;
	           }
	           else
	           k--;
	       }
	   }
	    return false;
	}
};

TC:O(n*n+nlog(n))

///////////////////
class Solution{
public:
	// Function to check if the
	// Pythagorean triplet exists or not
	bool checkTriplet(int arr[], int n) {
	    // code here
	    unordered_map<int,int>m;
	   for(int i=0;i<n;i++)
	   {
	       arr[i]=arr[i]*arr[i];
	       m[arr[i]]=i;
	   }
	   int sum=0;
	   for(int i=0;i<n;i++)
	   {
	       for(int j=i+1;j<n;j++)
	       {
	           sum=arr[i]+arr[j];
	           if(m.find(sum)!=m.end())
	           {
	               return true;
	           }
	       }
	   }
	    return false;
	}
};




TC:O(n*n)
