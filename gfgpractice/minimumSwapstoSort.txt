Given an array of size N. Find the minimum number of swaps required to sort the array in non-decreasing order.


Example 1:

Input: 
N = 5
arr = {1 5 4 3 2}
Output: 2
Explaination: swap 2 with 5 and 3 with 4.
 

Example 2:

Input: 
N = 4
arr[] = {8 9 16 15}
Output: 1
Explaination: swap 16 and 15.

int minSwaps(int arr[], int n){
    /*Your code here */
    //i think we should use bubble sort to find the number of swaps required
   unordered_map<int,int>m;
    int temp[n];int swapp=0;
    for(int i=0;i<n;i++)
    {
       temp[i]=arr[i];
       m[arr[i]]=i;
    }
    sort(temp,temp+n);
    for(int i=0;i<n;i++)
    {
        if(arr[i]!=temp[i])
        {
            int index=m[temp[i]];
            m[arr[i]]=index;
            m[temp[i]]=i;
            swap(arr[i],arr[index]);
            swapp++;
        }
    }
   return swapp;
}
///////
graph based method 
int minSwaps(int arr[], int n){
    /*Your code here */
    //i think we should use bubble sort to find the number of swaps required
   pair<int,int>p[n];int ans=0;
    int temp[n];int swapp=0;
    for(int i=0;i<n;i++)
    {
       p[i].first=arr[i];
       p[i].second=i;
    }
    sort(p,p+n);
    vector<int>visited(n,false);
    for(int i=0;i<n;i++)
    {
        if(visited[i] || p[i].second==i)//already at correct position
        {
            continue;
        }
        int cycle_size = 0;
        int j = i;
        while (!visited[j])
        {
            visited[j] = 1;
 
            // move to next node
            j = p[j].second;
            cycle_size++;
        }
 
        // Update answer by adding current cycle. 
        if (cycle_size > 0)
        {
            ans += (cycle_size - 1);
        }
    }  
        
   return ans;
}

Time Complexity: O(n Log n) 
Auxiliary Space: O(n)

