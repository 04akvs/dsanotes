

method 1: that comes to my mind is to find minimum of stack by traversing the whole stack though that will be an O(n) time approach 



void push(stack<int>& s, int a){
	// Your code goes here
	s.push(a);

    
}

bool isFull(stack<int>& s,int n){
	// Your code goes here
	return s.size()==n;
}

bool isEmpty(stack<int>& s){
	// Your code goes here
	return s.empty();
}

int pop(stack<int>& s){
	// Your code goes here
int x=s.top();
s.pop();
return x;
}

int getMin(stack<int>& s){
	// Your code goes here
	stack<int>st;int minn=10000;
	while(!isEmpty(s))
    {
    minn=min(minn,s.top());
    st.push(s.top());
    s.pop();
    }
    while(!isEmpty(st))
    {
        s.push(st.top());
        st.pop();
    }
    return minn;
   
}

TC:O(n)
sC:O(n)

method 2:


we take up an auxillary stack which will store the minimum element on top for every element being pushed 
eg for :  8 10 6 3 7 

aux stack will be : 8 8 6 3 3 

stack<int>st;
void push(stack<int>& s, int a){
	// Your code goes here
	
	if(s.empty() || a<st.top())
	{
	    st.push(a);
	}
	else
	{
	    st.push(st.top());
	}
	s.push(a);
}

bool isFull(stack<int>& s,int n){
	// Your code goes here
	return s.size()==n;
}

bool isEmpty(stack<int>& s){
	// Your code goes here
	return s.empty();
}

int pop(stack<int>& s){
	// Your code goes here
int x=s.top();
s.pop();
return x;
}

int getMin(stack<int>& s){
	// Your code goes here
	return st.top();//the top of the  auxillary stack stores the minimum element 

   
}


TC:O(1)

SC:O(n)



method 3: in O(1) space 





int minn=2e9;
void push(stack<int>& s, int a){
	// Your code goes here
	if(s.empty())
	{
	    s.push(a);
	    minn=a;//the first element is always the minimum 
	}
	else if(a>=minn)//if the element to be pushed is greater 
	{
	  
	        s.push(a);
	    
	}
	else//a is minn
	{
	  
	  s.push(2*a-minn);//push in 2*a -minn so that we can retrive new minn later when the current minimum gets popped out 
	  minn=a;//a will be minimum 
	}

}

bool isFull(stack<int>& s,int n){
	// Your code goes here
	return s.size()==n;
}

bool isEmpty(stack<int>& s){
	// Your code goes here
	return s.empty();
}

int pop(stack<int>& s){
	// Your code goes here
	int x=s.top();
if(x>=minn)
{
    s.pop();
}
else if(x<minn)
{
    minn=2*minn-x;
    s.pop();
}
return x;
}

int getMin(stack<int>& s){
	// Your code goes here
	return minn;
   
}



