Given a "connected" undirected graph. Perform a Depth First Traversal of the graph.
Note: Use recursive approach to find the DFS traversal of the graph starting from the 0th vertex from left to right according to the graph..


Example 1:

Input:
 0:1,4
 1:
 2:
 3:
 4:3



Output: 0 1 2 4 3
Explanation: 
0 is connected to 1, 2, 4.
1 is connected to 0.
2 is connected to 0.
3 is connected to 0.
4 is connected to 0, 3.
so starting from 0, it will go to 1 then 2
then 4, and then from 4 to 3.
Thus dfs will be 0 1 2 4 3.
Example 2:

Input:

Output: 0 1 2 3
Explanation:
0 is connected to 1 , 3.
1 is connected to 2. 
2 is connected to 1.
3 is connected to 0. 
so starting from 0, it will go to 1 then 2
then back to 0 then 0 to 3
thus dfs will be 0 1 2 3. 

Your task:
You don’t need to read input or print anything. Your task is to complete the function dfsOfGraph() which takes the integer V denoting the number of vertices and adjacency list as input parameters and returns  a list containing the DFS traversal of the graph starting from the 0th vertex from left to right according to the graph.


Expected Time Complexity: O(V + E)
Expected Auxiliary Space: O(V)


Constraints:
1 ≤ V, E ≤ 104




void dfs(int n,vector<int>adj[],int src,vector<int>&ans,vector<bool>&visited){
    ans.push_back(src);
    for(int i=0;i<adj[src].size();i++)//iterate its neighbours 
    {
        if(!visited[adj[src][i]]){
            visited[adj[src][i]]=true;//mark it as visited
            dfs(n,adj,adj[src][i],ans,visited);//now go deeper onto its direct neighbours 
        }
    }
}
	vector<int>dfsOfGraph(int n, vector<int> adj[]){
	    // Code here
	   //in dfs we follow depth search first 
	   //once we are onto a node ,we go deep down to all its adjacent neighbours 
	   vector<int>ans;
	   vector<bool>visited(n,false);//all nodes are unvisited 
	   visited[0]=true;
	   dfs(n,adj,0,ans,visited);
	   return ans;
	}

    TC:O(n+e)//e is the number of edges 
    SC:O(n)


stack based approach :



vector<int>dfsOfGraph(int n, vector<int> adj[]){
	    // Code here
	   //in dfs we follow depth search first 
	   //once we  are onto a node ,we go deep down to all its adjacent neighbours 
	   vector<int>ans;
	   vector<bool>visited(n,false);//all nodes are unvisited 
	   visited[0]=true;
	   stack<int>st;
	   st.push(0);
	   while(!st.empty()){
	       int src=st.top();
	       ans.push_back(st.top());
	       st.pop();
	       //now reach its neighbours
	       for(int i=adj[src].size()-1;i>=0;i--){
	           if(!visited[adj[src][i]]){
	              visited[adj[src][i]]=true;
	               st.push(adj[src][i]);
	           }
	       }
	   }
	   return ans;
	}


    