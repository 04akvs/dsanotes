Given a grid of size n*n filled with 0, 1, 2, 3. Check whether there is a path possible from the source to destination. You can traverse up, down, right and left.
The description of cells is as follows:

A value of cell 1 means Source.
A value of cell 2 means Destination.
A value of cell 3 means Blank cell.
A value of cell 0 means Wall.
Note: There are only a single source and a single destination.
 



Example 1:

Input: grid = {{3,0,3,0,0},{3,0,0,0,3}
,{3,3,3,3,3},{0,2,3,0,0},{3,0,0,1,3}}
Output: 0
Explanation: The grid is-
3 0 3 0 0 
3 0 0 0 3 
3 3 3 3 3 
0 2 3 0 0 
3 0 0 1 3 
There is no path to reach at (3,1) i,e at 
destination from (4,3) i,e source.
Example 2:

Input: grid = {{1,3},{3,2}}
Output: 1
Explanation: The grid is-
1 3
3 2
There is a path from (0,0) i,e source to (1,1) 
i,e destination.
 

Your Task:
You don't need to read or print anything. Your task is to complete the function is_Possible() which takes the grid as input parameter and returns boolean value true if there is a path otherwise returns false.
 

Expected Time Complexity: O(n2)
Expected Auxiliary Space: O(n2)
 

Constraints:
1 ≤ n ≤ 500



https://practice.geeksforgeeks.org/problems/find-whether-path-exist5238/1/?track=md-graph&batchId=144#




Method 1: DFS based approach 

void dfs(vector<vector<int>>&grid,int i,int j,vector<vector<bool>>&visit,bool &flag,int n){
    if(i>=n || j>=n || i<0 || j<0 || visit[i][j] || grid[i][j]==0 || flag ){
        return ;
    }
    if(grid[i][j]==2){//we reached our destination 
        flag=true;
        return ;
    }
    visit[i][j]=true;
    dfs(grid,i+1,j,visit,flag,n);//down
    dfs(grid,i-1,j,visit,flag,n);//up
    dfs(grid,i,j+1,visit,flag,n);//right
    dfs(grid,i,j-1,visit,flag,n);//left
}
    bool is_Possible(vector<vector<int>>& grid) {
        
        int n=grid.size();
        vector<vector<bool>>visit(n,vector<bool>(n,false));
        int srcx=-1;int srcy=-1;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1){
                    srcx=i;srcy=j;
                }
            }
        }
        bool flag=false;
        if(srcx==-1 && srcy==-1)
        return flag;
      dfs(grid,srcx,srcy,visit,flag,n);
      return flag;
    }
};


TC:O(n*n )
SC:O(n*n)


BFS:



bool is_Possible(vector<vector<int>>& grid) {
        
        int n=grid.size();
        vector<vector<bool>>visit(n,vector<bool>(n,false));
        int srcx=-1;int srcy=-1;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1){
                    srcx=i;srcy=j;
                }
            }
        }
        bool flag=false;
        if(srcx==-1 && srcy==-1)
        return flag;
        int dx[]={-1,0,0,1};
        int dy[]={0,-1,1,0};
        queue<pair<int,int>>q;
        q.push({srcx,srcy});
        while(!q.empty()){
            pair<int,int>p=q.front();
            q.pop();
            int i=p.first;int j=p.second;
            for(int k=0;k<4;k++){
                int x=i+dx[k];
                int y=j+dy[k];
                if(x<0 || x>=n || y<0 || y>=n)
                continue;
                if(visit[x][y])
                continue;
                if(grid[x][y]==2)
                {
                    flag=true;
                    break;
                }
                else if(grid[x][y]==3){
                    q.push({x,y});
                    visit[x][y]=true;
                }
            }
            
        }
      return flag;
    }
};


TC:O(n*n)

