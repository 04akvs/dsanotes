Given a Directed Graph. Find any Topological Sorting of that Graph.

Input:
The first line of input takes the number of test cases then T test cases follow . Each test case contains two lines. The first  line of each test case  contains two integers E and V representing no of edges and the number of vertices. Then in the next line are E  pairs of integers u, v representing an edge from u to v in the graph.

Output:
For each test case output will be 1 if the topological sort is done correctly else it will be 0.


void dfs(vector<int>adj[],int i,vector<bool>&visited,stack<int>&st)
{
    if(visited[i])
    return ;
   visited[i]=true;
   //now go for its neighbours
   for(int j=0;j<adj[i].size();j++)
   {
       if(visited[adj[i][j]]==false)
       {
           dfs(adj,adj[i][j],visited,st);
       }
   }
   st.push(i);
}
vector<int> topoSort(int V, vector<int> adj[]) {
    // Your code here
    vector<int>topo;
    vector<bool>visited(V,false);
    stack<int>st;
   
    //now call dfs for every node
    for(int i=0;i<V;i++)
    {
        if(visited[i]==false)
        dfs(adj,i,visited,st);
    }
    while(!st.empty())
    {
       topo.push_back(st.top());
       st.pop();
    }
    return topo;
    
}

TC:O(V+E)
SC:O(V)


/////////////////////////////////////////


Method 2: Kahn's algorithm for topological sorting 


void Graph::topologicalSort() 
{ 
    // Create a vector to store 
    // indegrees of all 
    // vertices. Initialize all 
    // indegrees as 0. 
    vector<int> in_degree(V, 0); 
  
    // Traverse adjacency lists 
    // to fill indegrees of 
    // vertices.  This step 
    // takes O(V+E) time 
    for (int u = 0; u < V; u++) { 
        list<int>::iterator itr; 
        for (itr = adj[u].begin(); 
             itr != adj[u].end(); itr++) 
            in_degree[*itr]++; 
    } 
  
    // Create an queue and enqueue 
    // all vertices with indegree 0 
    queue<int> q; 
    for (int i = 0; i < V; i++) 
        if (in_degree[i] == 0) 
            q.push(i); 
  
    // Initialize count of visited vertices 
    int cnt = 0; 
  
    // Create a vector to store 
    // result (A topological 
    // ordering of the vertices) 
    vector<int> top_order; 
  
    // One by one dequeue vertices 
    // from queue and enqueue 
    // adjacents if indegree of 
    // adjacent becomes 0 
    while (!q.empty()) { 
        // Extract front of queue 
        // (or perform dequeue) 
        // and add it to topological order 
        int u = q.front(); 
        q.pop(); 
        top_order.push_back(u); 
  
        // Iterate through all its 
        // neighbouring nodes 
        // of dequeued node u and 
        // decrease their in-degree 
        // by 1 
        list<int>::iterator itr; 
        for (itr = adj[u].begin(); 
             itr != adj[u].end(); itr++) 
  
            // If in-degree becomes zero, 
            // add it to queue 
            if (--in_degree[*itr] == 0) 
                q.push(*itr); 
  
        cnt++; 
    } 
  
    // Check if there was a cycle 
    if (cnt != V) { 
        cout << "There exists a cycle in the graph\n"; 
        return; 
    } 
  
    // Print topological order 
    for (int i = 0; i < top_order.size(); i++) 
        cout << top_order[i] << " "; 
    cout << endl; 
} 


TC:O(V+E)
SC:O(V)
