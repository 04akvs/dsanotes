You are given N pairs of numbers. In every pair, the first number is always smaller than the second number. A pair (c, d) can follow another pair (a, b) if b < c. Chain of pairs can be formed in this fashion. You have to find the longest chain which can be formed from the given set of pairs. 
 

Example 1:

Input:
N = 5
P[] = {5  24 , 39 60 , 15 28 , 27 40 , 50 90}
Output: 3
Explanation: The given pairs are { {5, 24}, {39, 60},
{15, 28}, {27, 40}, {50, 90} },the longest chain that
can be formed is of length 3, and the chain is
{{5, 24}, {27, 40}, {50, 90}}

â€‹Example 2:

Input:
N = 2
P[] = {5 10 , 1 11}
Output: 1
Explanation:The max length chain possible is only of
length one.






This problem can be easily solved using greedy approach.
It is a variation of the "Activity Selection" or "N meetings in one room" problem.


bool compare(const val&a,const val&b)
{
    return a.second<=b.second;
}
int maxChainLen(struct val p[],int n)
{
//Your code here
sort(p,p+n,compare);//sort by comparing shortest lengths first as that would be most optimal 
int end=0;int count=1;//count is initialized as 1 as we take in the smallest first 
for(int i=1;i<n;i++)
{
    if(p[i].first>p[end].second)
    {
        count++;
        end=i;
    }
    
}
return count;

}



TC:O(nlogn)

SC:O(1)
