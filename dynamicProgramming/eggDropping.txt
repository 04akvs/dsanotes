You are given K eggs, and you have access to a building with N floors from 1 to N. 

Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N). 

Your goal is to know with certainty what the value of F is.

What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?

 

Example 1:

Input: K = 1, N = 2
Output: 2
Explanation: 
Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
If it didn't break, then we know with certainty F = 2.
Hence, we needed 2 moves in the worst case to know what F is with certainty.


basic idea: recursive approach 

class Solution {
public:
    int eggdrop(int eggs,int floors)
    {
        if(eggs<=1 || floors<=1)
            return floors;
        int minn=INT_MAX;
        for(int i=1;i<=floors;i++)
        {
        int temp=1+max(eggdrop(eggs-1,i-1),eggdrop(eggs,floors-i));
                       if(temp<minn)
                       minn=temp;
        }
                       return minn;
    }
    int superEggDrop(int K, int N) {
        int eggs=K;int floors=N;
        return eggdrop(eggs,floors);
    }
};
TC:exponential 
//////////////////////////////////////////////////
class Solution {
public:
    int t[101][10001];
    int eggdrop(int eggs,int floors)
    {
        if(eggs<=1 || floors<=1)
            return floors;
        if(t[eggs][floors]!=-1)
            return t[eggs][floors];
        int minn=INT_MAX;
        for(int i=1;i<=floors;i++)
        {
        int temp=1+max(eggdrop(eggs-1,i-1),eggdrop(eggs,floors-i));
         if(temp<minn)
         minn=temp;
        }
    return t[eggs][floors]=minn;
    }
    int superEggDrop(int K, int N) {
        int eggs=K;int floors=N;
        memset(t,-1,sizeof(t));
        return eggdrop(eggs,floors);
    }
};
/////////////////////////////////////////////
Bottom up dp solution:
class Solution {
public:
    int superEggDrop(int K, int N) {
        int eggs=K;int floors=N;
        //bottom up dp solution
        int t[eggs+1][floors+1];
        //for one floor  , one attempt is needed
        for(int i=0;i<=eggs;i++)
        {
            t[i][1]=1;
            t[i][0]=0;//and for zero floors , no attempt is needed
        }
        //now for one egg , we need to check every floor 
        for(int j=0;j<=floors;j++)
        {
           t[1][j]=j; 
        }
        //now optimal substructure
        for(int i=2;i<=eggs;i++)
        {
            for(int j=2;j<=floors;j++)
            {
                t[i][j]=INT_MAX;
                for(int x=1;x<=j;x++)
                {
                    int temp=1+max(t[i-1][x-1],t[i][j-x]);
                    if(temp<t[i][j])
                        t[i][j]=temp;
                }
            }
        }
        return t[eggs][floors];
        
        
    }
};
TC:O(eggs*floors*floors)
SC:O(eggs*floors)
/////////////////////////////////////////////////////////
we need to furthur optimize this approach as it has chances to give TLE
for bigger values
K=6
N=1000
TLE
so instead of looping totally , we can use binary search technique
