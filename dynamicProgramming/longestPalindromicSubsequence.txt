Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.

Example 1:
Input:

"bbbab"
Output:
4
One possible longest palindromic subsequence is "bbbb".
 

Example 2:
Input:

"cbbd"

Brute force:find all the subsequences and check whether they are are palindromic or not 
class Solution {
public:
    int subse(string str,int i,int j)
    {
      if(i==j)//base case when only one character left
          return 1;
        if(str[i]==str[j] && i+1==j)//when only two characters left and both are equal
            return 2;
        if(str[i]==str[j])//if equal then the length gets added by two and recur of rest of the string 
            return 2+subse(str,i+1,j-1);
        else //if not same then take the maximum length obtained by one moving on by each character 
            return max(subse(str,i+1,j),subse(str,i,j-1));
    }
    int longestPalindromeSubseq(string s) {
        int n=s.size();
        if(n==1)
            return 1;
      int art=subse(s,0,n-1);  
        return art;
    }
};
TC:O(2^n)
SC: can cause stack overflow
////////////////////////////////--------------/////////////////////
class Solution {
public:
    int v[1001][1001];
    int subse(string str,int i,int j)
    {
        
      if(i==j)//base case when only one character left
          v[i][j]=1;
        if(str[i]==str[j] && i+1==j)//when only two characters left and both are equal
            v[i][j]=2;
        if(v[i][j]!=-1)
            return v[i][j];
        if(str[i]==str[j])//if equal then the length gets added by two and recur of rest of the string 
             v[i][j]= 2+subse(str,i+1,j-1);
        else //if not same then take the maximum length obtained by one moving on by each character 
            v[i][j]= max(subse(str,i+1,j),subse(str,i,j-1));
        return v[i][j];
    }
    int longestPalindromeSubseq(string s) {
        int n=s.size();
       for(int i=0;i<n+1;i++)
       {
           for(int j=0;j<n+1;j++)
           {
               v[i][j]=-1;
           }
       }
        if(n==1)
            return 1;
      int art=subse(s,0,n-1);  
        return art;
    }
};
but TLE
///////////////////////////////////////////////////////////////////
Bottom up dp: to vaoid calling recursion
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n=s.size();
        if(n==1)
            return 1;
        int t[n+1][n+1];
       for(int i=0;i<n+1;i++)
       {
           for(int j=0;j<n+1;j++)
           {
               if(i==j)
                   t[i][j]=1;
               
           }
       }
        for(int i=s.size()-1;i>=0;i--)
        {
            for(int j=i+1;j<n+1;j++)
            {
                if(s[i]==s[j] && i+1==j)
                    t[i][j]=2;
                else if(s[i]==s[j])
                    t[i][j]=2+t[i+1][j-1];
                else 
                    t[i][j]=max(t[i+1][j],t[i][j-1]);
            }
        }
        return t[0][n-1];
        
     
    }
};