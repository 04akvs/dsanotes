
       1(0)
    /    \
   2(-1)     3(1)
 /   \      \
4(-2)  5(0)   6(2)
Output: 4 2 1 5 3 6

//what we have to do in here is just bfs of the tree using queue 
and maintain a hashmap to store the nodes having the different distances

values stored in the map as are follows
             -2:4
             -1:2
              0:1,5,6
              1:3
              2:6
vector<int> verticalOrder(Node *root)
{
    //Your code here
    vector<int>nodes;
    if(root==NULL)
    return nodes;
    queue<pair<Node*,int> >q;
    q.push({root,0});
    map<int,vector<int> >m;   //vector to push in the nodes having same horizontal distances
    while(!q.empty())
    {
       pair<Node*,int>p=q.front();
       q.pop();
       Node* temp=p.first;
       int hd=p.second;
       if(temp->left)
       q.push({temp->left,hd-1});
       if(temp->right)
       q.push({temp->right,hd+1});
       m[hd].push_back(temp->data);
    }
    for(auto i:m)
    {
        for(auto j:i.second)
       nodes.push_back(j);
    }
    
}