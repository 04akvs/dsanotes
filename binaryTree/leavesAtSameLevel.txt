Given a Binary Tree, check if all leaves are at same level or not.

Example 1:

Input: 
            1
          /   \
         2     3

Output: 1

Explanation: 
Leaves 2 and 3 are at same level.

Example 2:

Input:
            10
          /    \
        20      30
       /  \        
     10    15

Output: 0

Explanation:
Leaves 10, 15 and 30 are not at same level.



bool check(Node *root)
{
    //Your code here
    if(root==NULL)
    return true;
    queue<Node*>q;int i=0;int count=0;
    unordered_map<int,int>m;
    q.push(root);
    while(!q.empty())
    {
        int sz=q.size();
        while(sz--)
        {
          Node* t=q.front();
            q.pop();
          if(t->left==NULL && t->right==NULL)
       {
           m[i]++;
       }
       if(t->left)
       q.push(t->left);
       if(t->right)
       q.push(t->right);
         }
    i++;
    }
    for(auto i:m)
    {
        if(i.second>0)
        {
            count++;
        }
    }
    return (count==1)?true:false;
    
}


TC:O(n)
sc:O(h)




recursive approach:



use set and see whether set conatins more than one height 


then return false


void  leaves(Node* root,int h,set<int>&level)
{
    if(root==NULL)
    return ;
    leaves(root->left,h+1,level);
    leaves(root->right,h+1,level);
    if(root->left==NULL && root->right==NULL)
    level.insert(h);
    
}
bool check(Node *root)
{
    //Your code here
    if(root==NULL)
    return true;
    set<int>level;
    int h=0;
    leaves(root,0,level);
    return level.size()>1?false:true;
    
}

